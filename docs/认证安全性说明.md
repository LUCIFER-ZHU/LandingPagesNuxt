# 认证安全性说明

## 📋 当前实现

目前项目使用 `localStorage` 存储用户认证信息（token 和用户数据），并通过 Pinia 的持久化插件自动管理。

```typescript
// app/stores/auth.ts
persist: {
  storage: localStorage  // 持久化到 localStorage
}
```

## ⚠️ localStorage 的安全风险

### 1. **XSS (跨站脚本攻击) 风险**

- **问题**：如果网站存在 XSS 漏洞，恶意脚本可以直接读取 localStorage 中的 token
- **示例**：
  ```javascript
  // 恶意脚本可以这样获取 token
  const token = localStorage.getItem('auth')
  // 然后发送到攻击者服务器
  ```

### 2. **无法设置过期时间**

- localStorage 数据永久保存，除非手动删除
- token 可能长期有效，增加被盗用的风险

### 3. **无法防止 CSRF**

- localStorage 的数据需要通过 JavaScript 手动添加到请求头
- 不像 cookie 那样自动携带

## ✅ 当前项目的安全措施

1. **只在客户端访问**
   ```typescript
   if (process.client) {
     // 只在浏览器端操作 localStorage
   }
   ```

2. **手动添加请求头**（已修改）
   - 不在拦截器中自动添加 token
   - 在需要的 API 中单独添加
   - 减少 token 暴露的范围

3. **退出登录清除状态**
   ```typescript
   authStore.clearAuth()  // 清除 localStorage
   ```

## 🔒 安全改进建议

### 方案 1：使用 httpOnly Cookie（推荐）

**优点：**
- JavaScript 无法访问，防止 XSS 攻击
- 自动携带到请求中
- 可以设置过期时间

**实现：**
```typescript
// 后端需要配合
// 登录成功后，后端设置 httpOnly cookie
res.cookie('auth_token', token, {
  httpOnly: true,     // JavaScript 无法访问
  secure: true,       // 只在 HTTPS 传输
  sameSite: 'strict', // 防止 CSRF
  maxAge: 7 * 24 * 60 * 60 * 1000  // 7天过期
})

// 前端不需要手动存储和发送 token
// Cookie 会自动携带到每个请求
```

**前端代码：**
```typescript
// 不需要在 localStorage 存储 token
export interface AuthState {
  user: User | null
  isAuthenticated: boolean
  // 不存储 token
}

// 不需要手动添加 Authorization 头
// Cookie 会自动发送
```

### 方案 2：Token 加密存储

如果必须使用 localStorage，可以加密存储：

```typescript
import CryptoJS from 'crypto-js'

const SECRET_KEY = 'your-secret-key'  // 应该从环境变量获取

// 加密存储
const encryptToken = (token: string) => {
  return CryptoJS.AES.encrypt(token, SECRET_KEY).toString()
}

// 解密读取
const decryptToken = (encryptedToken: string) => {
  const bytes = CryptoJS.AES.decrypt(encryptedToken, SECRET_KEY)
  return bytes.toString(CryptoJS.enc.Utf8)
}

// 使用
const encryptedToken = encryptToken(token)
localStorage.setItem('token', encryptedToken)
```

**注意**：这只是增加了攻击难度，并非完全安全。

### 方案 3：短期 Token + Refresh Token

**流程：**
1. 登录后获得短期 access token (15分钟) 和长期 refresh token (7天)
2. access token 存在内存中（不持久化）
3. refresh token 存在 httpOnly cookie 或加密的 localStorage
4. token 过期时，用 refresh token 换取新的 access token

**实现：**
```typescript
export interface AuthState {
  user: User | null
  accessToken: string | null      // 存内存，不持久化
  isAuthenticated: boolean
}

// Pinia 配置
persist: {
  storage: localStorage,
  paths: ['user', 'isAuthenticated']  // 只持久化用户信息，不持久化 token
}

// 自动刷新 token
const refreshAccessToken = async () => {
  const response = await $fetch('/api/refresh', {
    method: 'POST',
    credentials: 'include'  // 携带 refresh token cookie
  })
  authStore.setAccessToken(response.accessToken)
}
```

### 方案 4：使用 sessionStorage

如果不需要跨标签页保持登录：

```typescript
persist: {
  storage: sessionStorage  // 关闭标签页后自动清除
}
```

**优点：**
- 关闭浏览器自动清除
- 减少 token 被长期保留的风险

**缺点：**
- 用户体验较差（需要经常登录）

## 🎯 推荐方案（综合）

### 生产环境推荐配置

1. **使用 httpOnly Cookie 存储 token**
   ```typescript
   // nuxt.config.ts
   export default defineNuxtConfig({
     runtimeConfig: {
       public: {
         apiBase: process.env.NUXT_PUBLIC_API_BASE,
       }
     }
   })
   ```

2. **前端只存储必要的用户信息**
   ```typescript
   // app/stores/auth.ts
   export interface AuthState {
     user: User | null           // 存储
     isAuthenticated: boolean    // 存储
     // token 不存储，由 cookie 管理
   }
   ```

3. **配置 API 请求携带 cookie**
   ```typescript
   const customFetch = $fetch.create({
     baseURL: apiBase,
     credentials: 'include',  // 自动携带 cookie
   })
   ```

4. **后端配置 CORS**
   ```javascript
   // 后端配置
   app.use(cors({
     origin: 'https://your-domain.com',
     credentials: true,
     allowedHeaders: ['Content-Type', 'Authorization-Customer']
   }))
   ```

## 📝 其他安全建议

### 1. 内容安全策略 (CSP)

在 `nuxt.config.ts` 中配置：

```typescript
export default defineNuxtConfig({
  app: {
    head: {
      meta: [
        {
          'http-equiv': 'Content-Security-Policy',
          content: "default-src 'self'; script-src 'self' 'unsafe-inline' 'unsafe-eval';"
        }
      ]
    }
  }
})
```

### 2. HTTPS 强制

```typescript
// 生产环境强制使用 HTTPS
if (process.env.NODE_ENV === 'production' && !window.location.protocol.includes('https')) {
  window.location.href = window.location.href.replace('http:', 'https:')
}
```

### 3. Token 过期检测

```typescript
// 在拦截器中检测 401 错误
onResponseError({ response }) {
  if (response?.status === 401) {
    // Token 过期或无效
    const authStore = useAuthStore()
    authStore.clearAuth()
    navigateTo('/account/login')
  }
}
```

### 4. 定期更新依赖

```bash
# 检查安全漏洞
pnpm audit

# 更新依赖
pnpm update
```

### 5. 输入验证和输出转义

```typescript
// 防止 XSS - 验证邮箱格式
const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/
if (!emailRegex.test(email)) {
  throw new Error('Invalid email format')
}

// 使用 Vue 的自动转义
// {{ userInput }} 会自动转义 HTML
```

## 🔍 安全审计清单

- [ ] 使用 httpOnly cookie 存储敏感 token
- [ ] 启用 HTTPS
- [ ] 配置 CSP (Content Security Policy)
- [ ] 实现 token 刷新机制
- [ ] 添加请求频率限制
- [ ] 定期安全审计
- [ ] 使用环境变量管理密钥
- [ ] 启用 CORS 白名单
- [ ] 实现登录失败次数限制
- [ ] 添加用户活动日志

## 📚 参考资料

- [OWASP Top 10](https://owasp.org/www-project-top-ten/)
- [JWT Best Practices](https://tools.ietf.org/html/rfc8725)
- [Web Storage Security](https://cheatsheetseries.owasp.org/cheatsheets/HTML5_Security_Cheat_Sheet.html#local-storage)
- [Nuxt Security Guide](https://nuxt.com/docs/guide/going-further/security)

## 💡 结论

**当前方案（localStorage）：**
- ✅ 实现简单，开发快速
- ✅ 支持跨标签页登录状态
- ❌ 存在 XSS 风险
- ❌ Token 可能被恶意脚本窃取

**推荐生产方案（httpOnly Cookie）：**
- ✅ 更安全，防止 XSS
- ✅ 自动管理，代码更简洁
- ✅ 可设置过期时间
- ⚠️ 需要后端配合

**建议：**
- 开发阶段可以使用 localStorage（方便调试）
- 生产环境建议改用 httpOnly Cookie + Refresh Token
- 无论哪种方案，都要做好输入验证和 XSS 防护

